# Введение

Задача о ранце (или задача о рюкзаке) — NP-полная задача комбинаторной оптимизации. Своё название получила от конечной цели: уложить как можно большее число ценных вещей в рюкзак при условии, что вместимость рюкзака ограничена. С различными вариациями задачи о ранце можно столкнуться в экономике, прикладной математике, криптографии и логистике.
В общем виде задачу можно сформулировать так: из заданного множества предметов со свойствами «стоимость» и «вес» требуется отобрать подмножество с максимальной полной стоимостью, соблюдая при этом ограничение на суммарный вес.

# Теоретическая часть
### Ограниченный рюкзак (англ. Bounded Knapsack Problem) — обобщение классической задачи, когда любой предмет может быть взят некоторое количество раз.
## Формулировка задачи
Каждый предмет может быть выбран ограниченное *b<sub>i</sub>>* число раз. Задача выбрать число *x<sub>i</sub>>* предметов каждого типа так, чтобы
 - максимизировать общую стоимость: <img src="https://latex.codecogs.com/svg.latex?\sum_{i=1}^{N}p_{i}x_{i};" title="\sum_{i=1}^{N}p_{i}x_{i};" />
 - выполнялось условие совместности: <img src="https://latex.codecogs.com/svg.latex?\sum_{i=1}^{N}w_{i}x_{i}\leqW;" title="\sum_{i=1}^{N}w_{i}x_{i}\leqW;" />

## Варианты решения	
- Метод ветвей и границ.
- Метод динамического программирования.

## Выбор метода решения
Пусть *d(i,c)* максимальная стоимость любого количества вещей типов от 1 до *i* , суммарным весом до *c* включительно.
Заполним *d(0,c)* нулями.
Тогда меняя i от 1 до *N* , рассчитаем на каждом шаге *d(i,c)* , для *c* от 1 до *W* , по рекуррентной формуле:

<img src="https://latex.codecogs.com/svg.latex?d(i,&space;c)=max(d(i-1,c-lw_{i})&plus;lp_{i})" title="d(i, c)=max(d(i-1,c-lw_{i})+lp_{i})" />  по всем целым *l* из промежутка <img src="https://latex.codecogs.com/svg.latex?0\leq&space;l\leq&space;min(b_{i},\left&space;\lfloor&space;c/w_{i}&space;\right&space;\rfloor)" title="0\leq l\leq min(b_{i},\left \lfloor c/w_{i} \right \rfloor)" />

После выполнения в *d(N,W)* будет лежать максимальная стоимость предметов, помещающихся в рюкзак.

Сложность алгоритма *O(NW<sup>2</sup>)*.

### Неограниченный рюкзак (англ.Unbounded Knapsack Problem) — обобщение ограниченного рюкзака, в котором любой предмет может быть выбран любое количество раз.
## Формулировка задачи
Каждый предмет может быть выбран любое число раз. Задача выбрать количество *x<sub>i</sub>>* предметов каждого типа так, чтобы
- максимизировать общую стоимость: <img src="https://latex.codecogs.com/svg.latex?\sum_{i=1}^{N}x_{i}p_{i};" title="\sum_{i=1}^{N}x_{i}p_{i};" />
- выполнялось условие совместности: <img src="https://latex.codecogs.com/svg.latex?\sum_{i=1}^{N}w_{i}x_{i}\leq&space;W;" title="\sum_{i=1}^{N}w_{i}x_{i}\leq W;" />
где *x<sub>i</sub>>* <img src="https://latex.codecogs.com/svg.latex?\geq&space;0" title="\geq 0" /> целое, для всех *i=1,2,…,N* . 

## Варианты решения	
Самые распространенные методы точного решения это:
- Метод ветвей и границ.
- Метод динамического программирования.

## Выбор метода решения 

Для данной задачи наиболее оптимальным по памяти является метод динамического программирования.
Пусть *d(i,c)* максимальная стоимость любого количества вещей типов от 1 до *i* , суммарным весом до *c* включительно.
Заполним *d(0,c)* нулями.
Тогда меняя i от 1 до *N* , рассчитаем на каждом шаге *d(i,c)* , для *c* от 0 до *W* , по рекуррентной формуле:

<img src="https://latex.codecogs.com/svg.latex?d(i,c)\left\{\begin{matrix}&space;d(i-1,c)&space;\;&space;for&space;\;&space;c=0,...,w_{i}-1&space;\\&space;max(d(i-1,c),d(i,&space;c-w_{i})&plus;p_{i})&space;\;&space;for\;&space;c=w_{i},...,W;&space;\end{matrix}\right." title="d(i,c)\left\{\begin{matrix} d(i-1,c) \; for \; c=0,...,w_{i}-1 \\ max(d(i-1,c),d(i, c-w_{i})+p_{i}) \; for\; c=w_{i},...,W; \end{matrix}\right." />

После выполнения в *d(N,W)* будет лежать максимальная стоимость предметов, помещающихся в рюкзак.

Сложность алгоритма *O(NW)*.

#  Используемые структуры данных 


# Форматы входных и выходных данных

#### Программа принимает входные данные в виде двух текстовых файлов. 
 - Первый из файлов содержит в себе меню вида:
 ```
 #number (price calories)
 ```
 - Второй файл служит для хранения списка доступных акций 
  **type** - тип акции 
  **positions** - список продуктов, чтобы акцию получить (строка, где перечислены номера товаров через запятую)
  **discount** - бесплатный продукт или фиксированная цена (зависит от типа акции)

 ```
type products discount
 ```

#### На выходе программа выдает список товаров, которые нужно купить

# План решения
- решить как хранить информацию о меню и доступных акциях 
- реализовать второй алгоритм ( написать код для решения задачи о неограниченном рюкзаке )
- "догадаться, что акции своего рода продукт и на этом трудности с реализацие второго алгоритма заканчиваются"
- реализовать первый алгоритм (написать код для решения задачи о ограниченном рюкзаке)


# Оценка сложности основных алгоритмов программы, с доказательством.

## Первый алгоритм.

Сложность алгоритма зависит от размера меню, акций и списка товаров, которые нужно купить.
- N - количество продуктов из меню + количество акций
- W - сумма цен всех продуктов, которые нужно купить

Во время рассчетов двумерного списка выполняется N итераций внешнего цикла, и *W<sup>2</sup>* итераций внутреннего цикла- *O(NW<sup>2</sup>)*.
Рекурсивная функция поиска предметов, входящих в рюкзак, дает сложность O(NW) - в худшем случае.

Это дает нам сложность алгоритма *O(NW<sup>2</sup>+ NW)* = *O(NW<sup>2</sup>)*.


## Второй алгоритм.

Сложность алгоритма зависит от размера меню, акций и списка товаров, которые нужно купить.
- N - количество продуктов из меню + количество акций
- W - количество имеющихся денежных средств


Во время рассчетов двумерного списка выполняется N итераций внешнего цикла, и  W итерация внутреннего цикла- O(NW).
Рекурсивная функция поиска предметов, входящих в рюкзак, дает сложность O(NW) - в худшем случае.

Это дает нам сложность алгоритма O(2NW) = O (NW)




# Оценка использования памяти основными алгоритмами, с доказательством.

В программе выделяется память для хранения списка продуктов из файла menu.txt и списка акций из файла promo.txt .

Создается словарь размерность N в который заносятся все продукты и акции из этих двух списков (количество продуктов из меню + количество акций).


## Первый алгоритм.

Потребляемая память зависит от размера меню, акций и списка товаров, которые нужно купить.

Алгоритм выделяет память для двумерного массива размерностью NW для хранения калорий, где:
- N - количество продуктов из меню + количество акций
- W - сумма цен всех продуктов, которые нужно купить

В итоге сложность O(NW+N) = O(NW)


## Второй алгоритм.

Потребляемая память зависит от размера меню, акция и суммы на которую можно купить продукты.

Алгоритм выделяет память для двумерного массива размерностью O(NW) для хранения калорий, где:
- N - количество продуктов из меню + количество акций
- W - количество имеющихся денежных средств

В итоге сложность O(NW+N) = O(NW)

